# 操作系统

## 进程和线程有什么区别？
    - 线程是CPU调度的基本单位，一个进程里面可以有多个线程，但至少有一个线程
    - 进程是操作系统分配资源的最小单位

## 一个进程中有哪些数据段
    - 代码段（Text Segment）
        - 存储程序的执行代码。
        - 通常是只读的，以防止程序意外修改其指令。

    - 数据段（Data Segment）
        - **初始化数据段（Initialized Data Segment）**
            - 存储静态变量，即程序中明确赋值的全局变量和静态变量。
        - **未初始化数据段（Uninitialized Data Segment / BSS Segment）**
            - 存储未初始化的全局变量和静态变量。在程序开始执行之前，通常被初始化为零。

    - 堆段（Heap Segment）
        - 用于动态内存分配，如通过 `malloc`、`calloc`、`new` 等函数分配的内存。
        - 堆的大小不固定，可以在运行时动态增长和缩减。

    - 栈段（Stack Segment）
        - 存储局部变量、函数参数、返回地址及其他与函数调用相关的信息。
        - 栈是后进先出（LIFO）的数据结构，随函数调用而增长，函数返回时缩减。

    - 命令行参数和环境变量
        - 存储程序的命令行参数和环境变量。

    - 动态链接共享库信息
        - 在使用动态链接库的系统中，用于存储库的信息和管理代码。
    
## 同一个进程之间的不同线程之间有哪些数据段是共享的
    - 共享的段
        - 代码段（Text Segment）：所有线程共享同一代码段，因为它们执行相同程序的代码。
        - 数据段（Data Segment）：包括初始化的数据段和未初始化的数据段。这些段中包含的全局变量和静态变量对所有线程来说都是共享的。
        - 堆段（Heap Segment）：动态分配的内存（如通过 malloc、new 等分配的内存）位于堆段，这一部分内存也是由所有线程共享的。
        - 进程的命令行参数和环境变量对所有线程都是共享的。

    - 非共享的段
        - 栈段（Stack Segment）：每个线程有自己的栈，用于存储局部变量、函数调用的上下文等。线程的栈是独立的。
        - 寄存器和程序计数器：每个线程有自己的寄存器集合和程序计数器。

## 内核态和用户态是什么，他们有什么区别
    - 内核态（Kernel Mode） 和 用户态 （User Mode） 是操作系统中两种不容的执行模式，他们主要在于权限级别和能够执行的操作类型上有区别。这两种模式是现代操作系统用来保护系统稳定性和安全性的重要机制。

    - 内核态：
        - 权限：内核态拥有最高的全选。在这个模式下，代码可以直接访问所有的硬件资源和内存。
        - 功能：操作系统的核心部分，比如内核，在内核态下运行，可以执行包括硬件管理，内存管理，任务调度等低等级任务。
        - 安全和稳定性：由于内核态的代码完全控制系统，因此任何错误都可能会导致系统奔溃或安全漏洞。
    
    - 用户态：
        - 权限：用户态拥有较低的权限。在这个模式下，应用程序被限制只能访问被授权的内存区域和有限的硬件资源。
        - 功能：用户级应用程序在用户态运行，如文本编辑及，游戏和其他用户级软件。
        - 安全和稳定性：用户态提供了一个更安全的环境，因为应用程序无法直接访问硬件资源。这降低了一个错误应用程序导致整个系统崩溃的风险。
    
    - 两者的区别：
        - 权限访问：内核态可以访问所有系统的资源，而用户态只能访问有限类型的资源。
        - 切换：当应用程序需要执行一些需要高权限的操作时，比如读写硬盘中的文件，他会通过系统调用切换到内核态。系统调用完成后，再切换回用户态。
        - 安全性：用户态提供了一个相对安全的环境，以防止应用程序干扰系统的正常运行或其他应用程序。
        - 性能：从用户态切换到内核态会有一定的性能开销，因此操作系统设计上努力减少这种切换的频率。

## Linux进程通信的集中方式，以及各种方式的使用环境
    1. 管道 Pipes
        - 管道是最简单的进程通信形式，允许一个进程的输出直接成为另一个进程的输入
        - 他通常用于一些列命令之间的简单通信，比如 shell 脚本中的命令链 ( ls | grep "file.txt")
    2. 命名管道 Named Pipes 或 FIFO
        - 命名管道类似于匿名管道，但他们可以在文件系统中以文件的形式存在，因此不同的进程可以通过打开这个文件进行通信
        - 适用于不相关的进程之间通信，或者当进程在不同的时间运行时可以实现通信
    3. 信号 Signal
        - 信号是一种由操作系统提供的简单通信方式，用于通知进程发生了某个事件
        - 他们通常用于处理异常情况，如中断（Ctrl+C）或停止 （Ctrl+Z）
    4. 消息队列 Message Queues
        - 消息队列允许进程以消息的形式发送和接受数据，每个消息都有一个类型
        - 适用与不同进程间的复杂数据通信，特别是当信息的发送和接受需要解耦时
    5. 内存共享 Shard Memory
        - 共享内存允许两个或更多进程共享一个给定的内存区域
        - 适用于大量数据的快速交换，因为它减少了数据复制的幼，谈需要同步机制来避免静态条件
    6. 信号量 Semaphores
        - 信号量主要用于进程间的同步，尤其是控制对共享资源访问
        - 常用于控制对共享内存的访问或确保任务按顺序执行
    7. 套接字 Sockets
        - 套接字是更复杂的通信机制，允许在不同的机器上的进程之间进行通信
        - 适用于网络通信，或在同一个机器上的不同进程之间需要复杂的通信协议之间的情况
    8. 文件锁定 File Locking
        - 文件锁定不是直接的通信机制，但它允许进程控制对文件的访问，防止数据破坏
        - 当多个进程需要访问同一个文件时，用于保护文件不被同时写入

## 常见的进程调度策略有哪些
    1. 先来先服务 FCFS
        - 按照进程到达的顺序进行调度
    2. 最短作业时间 SJF
        - 优先执行运行时间短的进程来执行
    3. 最短剩余时间有限 SRTF
        - 类似于SJF，但是是抢占式的。如果新进程的预计运行时间比当前运行的进程少，调度将程序切换到新进程
        - 适用与交互式系统，需要更快的响应
    4. 轮转 RR Round Robin
        - 每一个进程被分配一个固定的时间片，用完时间片后，如果还没有完成，会被放到等待队列的末尾。
        - 一般用于时间共享操作系统，如多用户环境
    5. 优先级调度 Priority Scheduling
        - 每一个进程被分配一个优先级，调度程序总是运行优先级最高的可运行程序
        - 需要分区任务重要性的系统，如实时系统
    6. 多级队列 Multilevel Queue
        - 将进程分组到多个队列，每个队列有自己的调度算法。通常每个队列代表不同类别的进程
        - 不同类别的进程差异较大的环境
    7. 多级反馈队列 Multuilevel FeedBack Queue
        - 类似于多级队列，但是进程可以在队列之间移动。这种方式旨在提供一个平衡服务质量和响应时间的方法
        - 需要同时处理不同类型的进程的综合系统

## 什么是死锁 
    - 死锁是在多任务环境中，两个或者更多的进程或者线程在等待对方释放资源而陷入永久等待的状态，导致她们无法秩序执行的现象。在死锁状态下，每一个进程都持有对方需要的资源而等待对方先释放资源。

## 死锁的条件
    1. 互斥条件 Mutual Exclusion
        - 资源不能被多个进程共享，只能有一个进程在任一时刻使用
    2. 持有并持有条件 Hold and Wait
        - 一个进程至少持有一个资源，并等待获取其他进程占有的资源
    3. 非掠夺条件 No Preemption
        - 已分离给进程的资源不能被强制从该进程夺走，只能由持有资源的进程主动释放
    4. 存在一个进程等待链，其中每一个进程都在等待下一个进程所持有的资源

## 避免死锁的方法
    1. 打破互斥条件
        - 允许多个进程共享资源，但这个很多情况下不安全
    2. 打破持有并等待条件
        - 一次性分配所有必须的资源给进程，从而避免进程在持有资源的同时等待其他资源
        - 仅在进程没有任何资源时才允许请求资源
    3. 打破非掠夺条件
        - 如果一个已经持有某些资源的进程亲贵其他资源丙炔不能立即得到，那么他必须释放所有的资源，稍后再试
    4. 打破循环等待条件
        - 对资源进行排序，并强制每一个经常按照顺序请求资源，从而避免循环等待
    5. 资源分配策略
        - 使用银行家算法或者其他安全的资源分配算法，确保系统不进入不安全状态
    6. 检测和恢复
        - 定期家呢死锁并采取措施恢复，列入撤销某个进程或者强制释放资源
    7. 避免不必要的锁定
        - 减少资源的锁定需求，尽可能使用非锁定释放资源
    8. 超时限制
        - 对资源请求实施超时限制，超时后进程释放所有的资源