# 内存相关

## 讲讲页面置换算法LRU、FIFO
    
    - 最近做少使用 LRU
        - LRU算法是基于这样一个思想：如果一个页面在最近一段时间没有被使用，那么在将来某时间段内被使用的可能性也不大。因此，当发生页面置换时，LUR算法会选择选择最长时间没有使用的页面，并将其从内存中移除。
        - LRU算法的实现可以通过维护一个链表来完成。最近被访问的页面会被放到链表的头部，而每次页面访问时，都会更新这个链表。当需要置换页面时，链表的尾部，即最久没有被访问的页面会被选择并移除
        - LRU适用于需要考虑页面访问模式的场景，他比FIFO更能有效预测页面的使用模式，但实现起来更复杂，开销也比较大
    
    - 先进先出 FIFO
        - FIFO算法是一种更简单只管的页面置换方法。它基于先来先服务的原则，简单地移除最早进入内存的页面
        - FIFO算法的实现可以通过维护一个队列来实现，里面记录了内存的顺序，当需要进行页面置换时，最早进入没存的页面，即队列头部的页面会被移除
        - FIFO实现简单，开销很小，但是他不考虑页面的实际使用情况，可能会导致频繁使用的页面被置换，从而降低效率

    - 比较
        - 性能方面，通常情况下，LRU比FIFO表现更好，因为他多考虑的访问历史
        - 资源消耗方面，LRU在实现时需要额外的资源来跟着页面的访问历史，而FIFO实现起来更为简单
        - 适用性方面，LRY适用于哪些页面访问模式比较明显的场景，而FIFO适用于简单或资源受限的环境


## linux系统下在程序没问题的情况下有哪些场景会使某个进程突然停止运行
**内存耗尽（OOM Killer）**
- OOM（Out Of Memory）是指计算机系统中的内存耗尽的情况。当应用程序或系统进程请求的内存超过了系统能够提供或分配的最大内存时，就会发生OOM。这通常会导致出现错误，进程被终止，有时还可能导致整个系统变得不稳定或崩溃。

**OOM的原因**
- 内存泄露：应用程序因为代码缺陷未能释放不再使用的内存，导致随着时间推移内存使用不断增加。
- 过度分配：应用程序请求的内存量超出了系统的物理内存和交换空间（Swap Space）的总和。
- 多个进程竞争内存：多个运行中的进程竞争有限的内存资源，导致系统无法满足所有进程的内存需求。

**OOM的处理**
- 在多数操作系统中，当系统检测到内存不足以满足当前需求时，会触发OOM Killer（内存溢出杀手）机制。OOM Killer会根据一定的算法（如评估进程的内存使用量、运行时间、重要性等）选择并终止一个或多个进程，以释放内存，防止系统崩溃。被OOM Killer终止的进程通常是消耗内存最多的进程，但这也可能导致关键服务或应用意外终止。

**如何避免OOM**
- 代码优化：确保代码中没有内存泄露，合理管理内存使用，比如适时释放不再使用的资源。
- 资源监控：定期监控应用和系统的内存使用情况，及时发现和处理高内存消耗的问题。
- 合理配置：根据应用程序的内存需求，合理配置系统的物理内存和交换空间大小。
- 使用内存限制：在容器化（如Docker）或虚拟化环境中，可以为每个容器或虚拟机设置内存使用上限，以避免单个应用程序消耗所有可用内存。

OOM问题通常与应用程序的设计和内存管理方式密切相关，需要开发者在编写和部署应用程序时考虑和规划内存使用策略，以确保系统稳定运行。